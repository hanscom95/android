
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include "opencv2/opencv.hpp"
#include <iostream>

#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <iostream>
#include <algorithm>    // std::count
#include <vector>       // std::vector
#include <cmath>

#include <android/log.h>
using namespace std;
using namespace cv;

/*///// ANDROID REQUIREMENTS ///

// Make a single function that gets an image from camera, ouputs an augmented image(for debug) and gives back
// and int indicating the score


int autoScoring(Mat img, Mat& imgAug, int* colorCoors);

*/////////////////////////////


//////// DETECTION CONSTANTS ///////////
#define SCALE 4

const int TARGET10POINTS = 10;
const int TARGET6POINTS = 6;
const int TARGET5POINTS = 5;
int targetType = TARGET10POINTS;
int scoreOut = 0;
int callCounter = 0;

int elipsesVerified = false;
int numOfClusters = 5;
void isolateTarget(const Mat& input, Mat& TargetAreaMask);
void findPointsOnLine(const Mat& label);
void easyKmeans(const Mat& input, Mat& output, Mat& outputLabels);
void calculateColorLabelBasedMasks(const Mat& labels);
void findEdges(void);
void setSavedElipses(float* foundElipses);
void approximateElipses(void);
bool verifyElipsesRatios(void);
void drawElipses(Mat& debugImg);
void drawPoints(Mat& debugImg);
void obtainTestingAreaMasks(void);
bool sort_contours(const vector<Point>& contour1, const vector<Point> & contour2);
void checkImageSize(Mat& frame);
double getOrientation(vector<Point> &pts, Mat &img);
void obtainColorLabels(const int targetType);
int findColorLabelAtPoint(Point input);
Point findArrowTip(Mat& frame1, Mat& frame2, Mat& debugImg);
int scoreArrow(Point arrowTip);

void delSmallContours(vector<vector<Point> >& inputCont);
void delLowContours(vector<vector<Point> >& inputCont, int yCoor);
Point2f rotate2d(const Point2f& inPoint, const double& angRad);
Point2f rotatePoint(const Point2f& inPoint, const Point2f& center, const double& angDeg);
Point findRealArrowTip(void);

int yellowLabel = -1;
int redLabel = -1;
int blueLabel = -1;
int blackLabel = -1;
int whiteLabel = -1;

Mat img;
Scalar markerColor = Scalar(0);

const int numOfColors = 5;
const int numOfPoints = 4;
// Color Samples Coordinates
// Yellow  	 // Red			 // Blue		  // Black	 		// White
Point colorCoors[numOfColors] = { Point(0, 0), Point(0, 0), Point(0, 0), Point(0, 0), Point(0, 0) }; // Empty first
Point aristaCoors[numOfPoints] = { Point(0, 0), Point(0, 0), Point(0, 0), Point(0, 0) }; // Empty first

Point targetCenter = Point(0, 0);
vector<Vec3b> pointsOnLine;

// to be filled
int colorLabels[5] = { 0 }; // Yellow,  Red,  Blue, Black, White order

const int numOfElipses = 11; // Including X10
RotatedRect Elipses[numOfElipses]; // Elipses for Yellow, Red, Blue, Black, Yellow Middle, Red middle, Blue middle, Black middle, White

// Global Matrices
Mat ColorBasedMask[5];
Mat AreaBasedMask[5];
Mat MergedMask[5];
Mat TestMasks[numOfElipses]; // Testing Areas (Areas found by elipses) i=0, 10 points, i=9, 0 points
Mat Edges[5];
Mat ExpandedWhiteMask;
Mat TargetAreaMask;
Mat halfFromCenterMask;
Mat WhiteImg;
Mat arrowMask;

// used for finding interrupted arrows
const int rotDeg = -5;
const int numOfLines = 11; // (rotDeg *2 + 1)
Mat LinesMasks[numOfLines];

//  Mask obtained by color
const int YellowMask = 0;
const int RedMask = 1;
const int BlueMask = 2;
const int BlackMask = 3;
const int WhiteMask = 4;

// Mask obtained by marker positions
const int YellowAreaMask = 0;
const int RedAreaMask = 1;
const int BlueAreaMask = 2;
const int BlackAreaMask = 3;
const int WhiteAreaMask = 4;

bool debugMode = false;

Mat grayDif;
int frameCounter = 1;
int score = -1;
int oldScore = -1;

bool newArrow = false;
int CounterSinceLast = 0;
bool newScore = false;

bool paused = false;
bool segmentTarget = false;
bool finishedSegmentation = false;

Mat isolatedTarget;

Mat outputImg;
Mat labels;

bool varsInitialization = false;

bool frame1flag = false;
bool frame2flag = false;

const int arrowBinThresh = 20;
const int totalContourAreaThreshold = 100;
const int contourAreaThreshold = 50;
vector<vector<Point> > contours;
vector<vector<Point> > contours2;

const int pointSize = 2;

int width;
int height;

/* Header for class artech_com_fivics_autoScoringNativeClass_autoScoring */

#ifndef _Included_artech_com_fivics_autoScoringNativeClass_autoScoring
#define _Included_artech_com_fivics_autoScoringNativeClass_autoScoring
#ifdef __cplusplus
extern "C" {
#endif
	/*
	* Class:     artech_com_fivics_autoScoringNativeClass
	* Method:    autoScoringSegmentation, autoScoringEvaluation, detectMotion
	* Signature: (JJ)I
	*/

	JNIEXPORT jfloatArray JNICALL Java_artech_com_fivics_autoScoringNativeClass_autoScoringSegmentation
	(JNIEnv *, jclass, jlong, jintArray, jfloatArray);

	JNIEXPORT jint JNICALL Java_artech_com_fivics_autoScoringNativeClass_autoScoringEvaluation
	(JNIEnv *, jclass, jlong, jlong, jlong);

	JNIEXPORT jint JNICALL Java_artech_com_fivics_autoScoringNativeClass_detectMotion
	(JNIEnv *, jclass, jlong, jlong);

#ifdef __cplusplus
}
#endif
#endif